#!/usr/bin/env ruby

require 'optparse'
require 'rflow'

options = {
  :daemonize => true,
  :startup_log_level => 'INFO',
}

option_parser = OptionParser.new do |opts|
  opts.banner = <<EOB
Usage: rflow [options]
EOB

  opts.on("-f", "Run in the foreground") do |f|
    options[:daemonize] = false
  end

  opts.on("-c", "--config CONFIG", "Config file path") do |config|
    options[:config_file_path] = config
  end

  opts.on("-d", "--database DB", "Config database (sqlite) path") do |db|
    options[:config_database_path] = db
  end

  opts.on("-l", "--log DB", "Initial startup log file, defaults to STDERR") do |log|
    options[:startup_log_file_path] = log
  end

  opts.on("-v", "--verbose [LEVEL]", ['DEBUG'], "Control the startup log (and stderr) verbosity") do |level|
    options[:startup_log_level] = level || 'DEBUG'
  end
  
end
option_parser.parse!

# Set up the startup logging
log_pattern_formatter = PatternFormatter.new :pattern => RFlow::LOG_PATTERN_FORMAT
startup_logger = Logger.new 'startup'
startup_logger.add StderrOutputter.new('startup_stderr', :formatter => log_pattern_formatter)
startup_logger.level = LNAMES.index options[:startup_log_level]

if options[:startup_log_file_path]
  begin
    startup_logger.add FileOutputter.new('startup_file', :filename => options[:startup_log_file_path], :formatter => log_pattern_formatter)
  rescue Exception => e
    startup_logger.fatal "Log file '#{options[:startup_log_file_path]}' problem: #{e.message}"
    exit 1
  end
end

RFlow.logger = startup_logger

unless options[:config_database_path]
  startup_logger.warn "Config database not specified, using default 'config.sqlite'"
  options[:config_database_path] = 'config.sqlite'
end

# If the config file was specified, load a new database with it.
if options[:config_file_path]
  unless File.exist? options[:config_file_path]
    startup_logger.fatal "Config file '#{options[:config_file_path]}' not found\n#{option_parser.help}"
    exit 1
  end

  unless File.readable? options[:config_file_path]
    startup_logger.fatal "Config file '#{options[:config_file_path]}' not readable\n#{option_parser.help}"
    exit 1
  end

  if File.exist? options[:config_database_path]
    startup_logger.fatal "Config database '#{options[:config_database_path]}' exists, exiting to prevent accidental overwrite from config file '#{options[:config_file_path]}'"
    exit 1
  end
end

# Initialize the configuration database, if needed
unless File.exist? options[:config_database_path]
  startup_logger.warn "Config database '#{options[:config_database_path]}' not found, creating"
  RFlow.initialize_config_database(options[:config_database_path], options[:config_file_path])
end

unless File.readable? options[:config_database_path]
  startup_logger.fatal "Config database '#{options[:config_database_path]}' not reabable\n#{option_parser.help}"
  exit 1
end

# Start the flow
RFlow.run options[:config_database_path], options[:daemonize]

__END__

# TODO: all the stuffs after here
# rflow <config file>
#   figure out a work directory
#   make sure that it has the right subdirectories (can be overridden)
#     run tmp logs schemas components
#   Set up logging to logs/rflow.log
#   Load all schemas
#   Verify all component installation
#   Initialize components
#   Start components running and make sure that they "daemonize" correctly
#     - place pid files in deployment's run directory
#   Configure components via zmq
#   Daemonize self
# 
# rflow init -- separate script
#   sets up the following directories
#     run/tmp/logs/schemas/components
